# search.py# ---------# Licensing Information:  You are free to use or extend these projects for# educational purposes provided that (1) you do not distribute or publish# solutions, (2) you retain this notice, and (3) you provide clear# attribution to UC Berkeley, including a link to http://ai.berkeley.edu.# # Attribution Information: The Pacman AI projects were developed at UC Berkeley.# The core projects and autograders were primarily created by John DeNero# (denero@cs.berkeley.edu) and Dan Klein (klein@cs.berkeley.edu).# Student side autograding was added by Brad Miller, Nick Hay, and# Pieter Abbeel (pabbeel@cs.berkeley.edu)."""In search.py, you will implement generic search algorithms which are called byPacman agents (in searchAgents.py)."""import utilclass SearchProblem:    """    This class outlines the structure of a search problem, but doesn't implement    any of the methods (in object-oriented terminology: an abstract class).    You do not need to change anything in this class, ever.    """    def getStartState(self):        """        Returns the start state for the search problem.        """        util.raiseNotDefined()    def isGoalState(self, state):        """          state: Search state        Returns True if and only if the state is a valid goal state.        """        util.raiseNotDefined()    def getSuccessors(self, state):        """          state: Search state        For a given state, this should return a list of triples, (successor,        action, stepCost), where 'successor' is a successor to the current        state, 'action' is the action required to get there, and 'stepCost' is        the incremental cost of expanding to that successor.        """        util.raiseNotDefined()    def getCostOfActions(self, actions):        """         actions: A list of actions to take        This method returns the total cost of a particular sequence of actions.        The sequence must be composed of legal moves.        """        util.raiseNotDefined()def nullHeuristic(state, problem=None):    """    A heuristic function estimates the cost from the current state to the nearest    goal in the provided SearchProblem.  This heuristic is trivial.    """    return 0class Node:    def __init__(self, state, action, cost, previous):        self.state = state        self.action = action        self.cost = cost        self.previous = previous    def __repr__(self):        return "Pacman is now at {0} and will take {1} action.".format(self.state, self.action)class Search:    def __init__(self, problem, algorithm, heuristic=nullHeuristic):        self.problem = problem        self.algorithm = algorithm        self.visited = list()        self.container = None        self.heuristic = heuristic        self.priority = False        if algorithm == "depthFirstSearch":            self.container = util.Stack()        elif algorithm == "breadthFirstSearch":            self.container = util.Queue()        else:            # uniformCostSearch and aStarSearch            self.container = util.PriorityQueue()            self.priority = True    def search(self):        # Adding initial nodes        start = self.problem.getStartState()        if self.priority:            self.container.push(Node(start, None, self.heuristic(start, self.problem), None),                                self.heuristic(start, self.problem))        else:            self.container.push(Node(start, None, self.heuristic(start, self.problem), None))        # Loop until the end is found        while not self.container.isEmpty():            # Getting the current location            node = self.container.pop()            # If reach the target point            if self.problem.isGoalState(node.state):                # Retrace the full path                actions = list()                while not (node.action is None):                    actions.append(node.action)                    node = node.previous                # Flip action list                actions.reverse()                return actions            # If the target point is not reached and the point has not been visited            if node.state not in self.visited:                # Mark that the point has been visited                self.visited.append(node.state)                # Adding successor nodes                for successor in self.problem.getSuccessors(node.state):                    if self.priority:                        self.container.push(Node(successor[0], successor[1], successor[2]+node.cost, node),                                            successor[2]+node.cost+self.heuristic(successor[0], self.problem))                    else:                        self.container.push(Node(successor[0], successor[1], successor[2] + node.cost, node))def tinyMazeSearch(problem):    """    Returns a sequence of moves that solves tinyMaze.  For any other maze, the    sequence of moves will be incorrect, so only use this for tinyMaze.    """    from game import Directions    s = Directions.SOUTH    w = Directions.WEST    return [s, s, w, s, w, w, s, w]def depthFirstSearch(problem: SearchProblem):    """    Search the deepest nodes in the search tree first.    Your search algorithm needs to return a list of actions that reaches the    goal. Make sure to implement a graph search algorithm.    To get started, you might want to try some of these simple commands to    understand the search problem that is being passed in:    print("Start:", problem.getStartState())    print("Is the start a goal?", problem.isGoalState(problem.getStartState()))    print("Start's successors:", problem.getSuccessors(problem.getStartState()))    """    "*** YOUR CODE HERE ***"    return Search(problem, "depthFirstSearch").search()def breadthFirstSearch(problem: SearchProblem):    """Search the shallowest nodes in the search tree first."""    "*** YOUR CODE HERE ***"    return Search(problem, "breadthFirstSearch").search()def uniformCostSearch(problem: SearchProblem):    """Search the node of least total cost first."""    "*** YOUR CODE HERE ***"    return Search(problem, "uniformCostSearch").search()def aStarSearch(problem: SearchProblem, heuristic=nullHeuristic):    """Search the node that has the lowest combined cost and heuristic first."""    "*** YOUR CODE HERE ***"    return Search(problem, "aStarSearch", heuristic).search()# Abbreviationsbfs = breadthFirstSearchdfs = depthFirstSearchastar = aStarSearchucs = uniformCostSearch